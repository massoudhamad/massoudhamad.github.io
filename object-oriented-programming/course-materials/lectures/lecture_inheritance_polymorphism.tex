\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=2.5cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{tcolorbox}
\usepackage{amssymb}

\definecolor{primary}{RGB}{5, 150, 105}
\definecolor{codebg}{RGB}{248, 249, 250}
\definecolor{codegreen}{RGB}{34, 139, 34}
\definecolor{codepurple}{RGB}{128, 0, 128}
\definecolor{codeblue}{RGB}{0, 0, 205}
\definecolor{codeorange}{RGB}{255, 140, 0}

\lstdefinestyle{java}{
    backgroundcolor=\color{codebg},
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    language=Java,
    keywordstyle=\color{codeblue}\bfseries,
    stringstyle=\color{codegreen},
    commentstyle=\color{gray}\itshape,
    morekeywords={String, System, Scanner, ArrayList, List, Override, abstract, interface, implements, extends},
    showstringspaces=false,
    tabsize=4,
    numbers=left,
    numberstyle=\tiny\color{gray},
    numbersep=5pt
}

\lstset{style=java}

\newtcolorbox{definitionbox}[1][]{
    colback=green!5!white,
    colframe=primary,
    title=#1,
    fonttitle=\bfseries
}

\newtcolorbox{notebox}[1][]{
    colback=yellow!10!white,
    colframe=orange!80!black,
    title=#1,
    fonttitle=\bfseries
}

\newtcolorbox{exercisebox}[1][]{
    colback=blue!5!white,
    colframe=blue!70!black,
    title=#1,
    fonttitle=\bfseries
}

\hypersetup{
    colorlinks=true,
    linkcolor=primary,
    urlcolor=primary
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Object-Oriented Programming}
\fancyhead[R]{Inheritance, Polymorphism, Abstract \& Interface}
\fancyfoot[C]{\thepage}
\setlength{\headheight}{14.5pt}

\title{\textbf{Inheritance, Polymorphism, Abstract Classes \& Interfaces}\\[0.5cm]\large Object-Oriented Programming in Java}
\author{State University of Zanzibar (SUZA)\\BSc Computer Science}
\date{}

\begin{document}

\maketitle
\tableofcontents
\newpage

%==============================================================================
% PART 1: INHERITANCE
%==============================================================================
\section{Inheritance}

\subsection{What is Inheritance?}

\begin{definitionbox}[Definition]
\textbf{Inheritance} is a fundamental OOP concept where a new class (child/subclass) is created from an existing class (parent/superclass). The child class inherits all the attributes and methods of the parent class and can add its own unique features.
\end{definitionbox}

\subsection{Why Use Inheritance?}

\begin{itemize}
    \item \textbf{Code Reusability:} Write code once in the parent class, use it in multiple child classes
    \item \textbf{Method Overriding:} Child classes can provide specific implementations
    \item \textbf{Hierarchical Classification:} Organize classes in a logical hierarchy
    \item \textbf{Extensibility:} Extend existing functionality without modifying original code
\end{itemize}

\subsection{Inheritance Syntax in Java}

\begin{lstlisting}
// Parent class (Superclass)
class Animal {
    String name;
    int age;

    public void eat() {
        System.out.println(name + " is eating.");
    }

    public void sleep() {
        System.out.println(name + " is sleeping.");
    }
}

// Child class (Subclass)
class Dog extends Animal {
    String breed;

    public void bark() {
        System.out.println(name + " is barking: Woof!");
    }
}
\end{lstlisting}

\subsection{The \texttt{extends} Keyword}

In Java, we use the \texttt{extends} keyword to create inheritance:

\begin{lstlisting}
class ChildClass extends ParentClass {
    // Child class body
}
\end{lstlisting}

\subsection{Types of Inheritance}

\subsubsection{1. Single Inheritance}
One child class inherits from one parent class.

\begin{lstlisting}
class Vehicle {
    String brand;
    int year;

    public void start() {
        System.out.println("Vehicle starting...");
    }
}

class Car extends Vehicle {
    int numberOfDoors;

    public void honk() {
        System.out.println("Beep beep!");
    }
}
\end{lstlisting}

\subsubsection{2. Multilevel Inheritance}
A class inherits from a class that also inherits from another class.

\begin{lstlisting}
class Animal {
    public void breathe() {
        System.out.println("Breathing...");
    }
}

class Mammal extends Animal {
    public void feedMilk() {
        System.out.println("Feeding milk to young ones.");
    }
}

class Dog extends Mammal {
    public void bark() {
        System.out.println("Barking...");
    }
}

// Dog can use breathe(), feedMilk(), and bark()
\end{lstlisting}

\subsubsection{3. Hierarchical Inheritance}
Multiple child classes inherit from a single parent class.

\begin{lstlisting}
class Shape {
    String color;

    public void draw() {
        System.out.println("Drawing a shape");
    }
}

class Circle extends Shape {
    double radius;

    public double getArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape {
    double width, height;

    public double getArea() {
        return width * height;
    }
}
\end{lstlisting}

\begin{notebox}[Important Note]
Java does NOT support multiple inheritance with classes (a class cannot extend more than one class). This is to avoid the "Diamond Problem". However, Java supports multiple inheritance through interfaces.
\end{notebox}

\subsection{The \texttt{super} Keyword}

The \texttt{super} keyword refers to the parent class. It is used to:

\subsubsection{1. Call Parent Constructor}
\begin{lstlisting}
class Person {
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

class Student extends Person {
    String studentId;

    public Student(String name, int age, String studentId) {
        super(name, age);  // Call parent constructor
        this.studentId = studentId;
    }
}
\end{lstlisting}

\subsubsection{2. Access Parent Methods}
\begin{lstlisting}
class Animal {
    public void makeSound() {
        System.out.println("Some generic sound");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        super.makeSound();  // Call parent method first
        System.out.println("Meow!");
    }
}
\end{lstlisting}

\subsubsection{3. Access Parent Variables}
\begin{lstlisting}
class Parent {
    String message = "Hello from Parent";
}

class Child extends Parent {
    String message = "Hello from Child";

    public void displayMessages() {
        System.out.println(message);        // Child's message
        System.out.println(super.message);  // Parent's message
    }
}
\end{lstlisting}

\subsection{Complete Inheritance Example}

\begin{lstlisting}
// Base class
class Employee {
    private String name;
    private String employeeId;
    protected double baseSalary;

    public Employee(String name, String employeeId, double baseSalary) {
        this.name = name;
        this.employeeId = employeeId;
        this.baseSalary = baseSalary;
    }

    public String getName() {
        return name;
    }

    public double calculateSalary() {
        return baseSalary;
    }

    public void displayInfo() {
        System.out.println("Name: " + name);
        System.out.println("ID: " + employeeId);
        System.out.println("Salary: $" + calculateSalary());
    }
}

// Derived class
class Manager extends Employee {
    private double bonus;
    private int teamSize;

    public Manager(String name, String id, double salary,
                   double bonus, int teamSize) {
        super(name, id, salary);
        this.bonus = bonus;
        this.teamSize = teamSize;
    }

    @Override
    public double calculateSalary() {
        return baseSalary + bonus;
    }

    @Override
    public void displayInfo() {
        super.displayInfo();
        System.out.println("Team Size: " + teamSize);
        System.out.println("Bonus: $" + bonus);
    }
}

// Main class
public class InheritanceDemo {
    public static void main(String[] args) {
        Employee emp = new Employee("John", "E001", 50000);
        Manager mgr = new Manager("Alice", "M001", 70000, 15000, 10);

        System.out.println("=== Employee ===");
        emp.displayInfo();

        System.out.println("\n=== Manager ===");
        mgr.displayInfo();
    }
}
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
=== Employee ===
Name: John
ID: E001
Salary: $50000.0

=== Manager ===
Name: Alice
ID: M001
Salary: $85000.0
Team Size: 10
Bonus: $15000.0
\end{verbatim}

%==============================================================================
% PART 2: POLYMORPHISM
%==============================================================================
\newpage
\section{Polymorphism}

\subsection{What is Polymorphism?}

\begin{definitionbox}[Definition]
\textbf{Polymorphism} means "many forms". In OOP, it refers to the ability of objects to take on multiple forms. The same method name can behave differently based on which object calls it or what parameters are passed.
\end{definitionbox}

\subsection{Types of Polymorphism}

\begin{enumerate}
    \item \textbf{Compile-time Polymorphism} (Static) - Method Overloading
    \item \textbf{Runtime Polymorphism} (Dynamic) - Method Overriding
\end{enumerate}

\subsection{Method Overloading (Compile-time Polymorphism)}

Method overloading allows multiple methods with the \textbf{same name} but \textbf{different parameters} in the same class.

\begin{lstlisting}
class Calculator {
    // Method with two int parameters
    public int add(int a, int b) {
        return a + b;
    }

    // Method with three int parameters
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // Method with two double parameters
    public double add(double a, double b) {
        return a + b;
    }

    // Method with String parameters (concatenation)
    public String add(String a, String b) {
        return a + b;
    }
}

public class OverloadingDemo {
    public static void main(String[] args) {
        Calculator calc = new Calculator();

        System.out.println(calc.add(5, 10));           // 15
        System.out.println(calc.add(5, 10, 15));       // 30
        System.out.println(calc.add(5.5, 10.5));       // 16.0
        System.out.println(calc.add("Hello ", "World")); // Hello World
    }
}
\end{lstlisting}

\begin{notebox}[Rules for Method Overloading]
\begin{itemize}
    \item Methods must have the \textbf{same name}
    \item Methods must have \textbf{different parameter lists} (number, type, or order)
    \item Return type alone is NOT sufficient to overload a method
    \item Access modifiers can be different
\end{itemize}
\end{notebox}

\subsection{Method Overriding (Runtime Polymorphism)}

Method overriding occurs when a child class provides a \textbf{specific implementation} of a method that is already defined in its parent class.

\begin{lstlisting}
class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound");
    }

    public void move() {
        System.out.println("Animal moves");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Dog barks: Woof! Woof!");
    }

    @Override
    public void move() {
        System.out.println("Dog runs on four legs");
    }
}

class Bird extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Bird chirps: Tweet! Tweet!");
    }

    @Override
    public void move() {
        System.out.println("Bird flies with wings");
    }
}

class Fish extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Fish doesn't make sound");
    }

    @Override
    public void move() {
        System.out.println("Fish swims in water");
    }
}
\end{lstlisting}

\begin{notebox}[Rules for Method Overriding]
\begin{itemize}
    \item Method must have the \textbf{same name and parameters}
    \item Method must have the \textbf{same or covariant return type}
    \item Method cannot have a more restrictive access modifier
    \item Use \texttt{@Override} annotation (recommended)
    \item \texttt{static}, \texttt{final}, and \texttt{private} methods cannot be overridden
\end{itemize}
\end{notebox}

\subsection{Polymorphism in Action}

The power of polymorphism is shown when a parent reference holds a child object:

\begin{lstlisting}
public class PolymorphismDemo {
    public static void main(String[] args) {
        // Parent reference, Child object
        Animal animal1 = new Dog();
        Animal animal2 = new Bird();
        Animal animal3 = new Fish();

        // Same method call, different behavior
        animal1.makeSound();  // Dog barks: Woof! Woof!
        animal2.makeSound();  // Bird chirps: Tweet! Tweet!
        animal3.makeSound();  // Fish doesn't make sound

        System.out.println();

        animal1.move();  // Dog runs on four legs
        animal2.move();  // Bird flies with wings
        animal3.move();  // Fish swims in water

        // Using an array of Animals
        System.out.println("\n--- Animal Orchestra ---");
        Animal[] animals = {new Dog(), new Bird(), new Fish()};

        for (Animal a : animals) {
            a.makeSound();
        }
    }
}
\end{lstlisting}

\subsection{Real-World Example: Payment System}

\begin{lstlisting}
class Payment {
    protected double amount;

    public Payment(double amount) {
        this.amount = amount;
    }

    public void processPayment() {
        System.out.println("Processing generic payment of $" + amount);
    }

    public void printReceipt() {
        System.out.println("Receipt: $" + amount + " paid.");
    }
}

class CreditCardPayment extends Payment {
    private String cardNumber;

    public CreditCardPayment(double amount, String cardNumber) {
        super(amount);
        this.cardNumber = cardNumber;
    }

    @Override
    public void processPayment() {
        System.out.println("Processing credit card payment...");
        System.out.println("Card: **** **** **** " +
                           cardNumber.substring(cardNumber.length() - 4));
        System.out.println("Amount: $" + amount);
        System.out.println("Payment successful!");
    }
}

class MobilePayment extends Payment {
    private String phoneNumber;

    public MobilePayment(double amount, String phoneNumber) {
        super(amount);
        this.phoneNumber = phoneNumber;
    }

    @Override
    public void processPayment() {
        System.out.println("Processing mobile money payment...");
        System.out.println("Phone: " + phoneNumber);
        System.out.println("Amount: $" + amount);
        System.out.println("Check your phone for confirmation.");
    }
}

class BankTransfer extends Payment {
    private String accountNumber;

    public BankTransfer(double amount, String accountNumber) {
        super(amount);
        this.accountNumber = accountNumber;
    }

    @Override
    public void processPayment() {
        System.out.println("Processing bank transfer...");
        System.out.println("Account: " + accountNumber);
        System.out.println("Amount: $" + amount);
        System.out.println("Transfer initiated. Allow 1-3 business days.");
    }
}

public class PaymentDemo {
    public static void main(String[] args) {
        // Polymorphism: Different payment types
        Payment[] payments = {
            new CreditCardPayment(150.00, "1234567890123456"),
            new MobilePayment(75.50, "+255-123-456-789"),
            new BankTransfer(500.00, "ACC-001234567")
        };

        for (Payment p : payments) {
            p.processPayment();
            p.printReceipt();
            System.out.println("-------------------");
        }
    }
}
\end{lstlisting}

%==============================================================================
% PART 3: ABSTRACT CLASSES
%==============================================================================
\newpage
\section{Abstract Classes}

\subsection{What is an Abstract Class?}

\begin{definitionbox}[Definition]
An \textbf{Abstract Class} is a class that cannot be instantiated (you cannot create objects from it). It serves as a blueprint for other classes and can contain both abstract methods (without implementation) and concrete methods (with implementation).
\end{definitionbox}

\subsection{Abstract Class Syntax}

\begin{lstlisting}
abstract class ClassName {
    // Regular variables
    private String name;

    // Constructor
    public ClassName(String name) {
        this.name = name;
    }

    // Abstract method (no body)
    public abstract void abstractMethod();

    // Concrete method (has body)
    public void concreteMethod() {
        System.out.println("This is a concrete method");
    }
}
\end{lstlisting}

\subsection{Key Characteristics of Abstract Classes}

\begin{itemize}
    \item Declared with the \texttt{abstract} keyword
    \item \textbf{Cannot be instantiated} directly
    \item Can have abstract methods (must be overridden by subclasses)
    \item Can have concrete methods (inherited by subclasses)
    \item Can have constructors, variables, and static methods
    \item A class that extends an abstract class must implement all abstract methods OR be declared abstract itself
\end{itemize}

\subsection{Abstract Class Example: Shape}

\begin{lstlisting}
abstract class Shape {
    protected String color;

    public Shape(String color) {
        this.color = color;
    }

    // Abstract methods - must be implemented by subclasses
    public abstract double calculateArea();
    public abstract double calculatePerimeter();

    // Concrete method - inherited by subclasses
    public void displayColor() {
        System.out.println("Color: " + color);
    }

    public void displayInfo() {
        displayColor();
        System.out.println("Area: " + calculateArea());
        System.out.println("Perimeter: " + calculatePerimeter());
    }
}

class Circle extends Shape {
    private double radius;

    public Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }

    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }

    @Override
    public double calculatePerimeter() {
        return 2 * Math.PI * radius;
    }
}

class Rectangle extends Shape {
    private double width;
    private double height;

    public Rectangle(String color, double width, double height) {
        super(color);
        this.width = width;
        this.height = height;
    }

    @Override
    public double calculateArea() {
        return width * height;
    }

    @Override
    public double calculatePerimeter() {
        return 2 * (width + height);
    }
}

class Triangle extends Shape {
    private double base;
    private double height;
    private double side1, side2, side3;

    public Triangle(String color, double base, double height,
                    double s1, double s2, double s3) {
        super(color);
        this.base = base;
        this.height = height;
        this.side1 = s1;
        this.side2 = s2;
        this.side3 = s3;
    }

    @Override
    public double calculateArea() {
        return 0.5 * base * height;
    }

    @Override
    public double calculatePerimeter() {
        return side1 + side2 + side3;
    }
}

public class AbstractShapeDemo {
    public static void main(String[] args) {
        // Cannot do: Shape s = new Shape("Red"); // Error!

        Shape circle = new Circle("Red", 5.0);
        Shape rectangle = new Rectangle("Blue", 4.0, 6.0);
        Shape triangle = new Triangle("Green", 3.0, 4.0, 3.0, 4.0, 5.0);

        System.out.println("=== Circle ===");
        circle.displayInfo();

        System.out.println("\n=== Rectangle ===");
        rectangle.displayInfo();

        System.out.println("\n=== Triangle ===");
        triangle.displayInfo();
    }
}
\end{lstlisting}

\textbf{Output:}
\begin{verbatim}
=== Circle ===
Color: Red
Area: 78.53981633974483
Perimeter: 31.41592653589793

=== Rectangle ===
Color: Blue
Area: 24.0
Perimeter: 20.0

=== Triangle ===
Color: Green
Area: 6.0
Perimeter: 12.0
\end{verbatim}

%==============================================================================
% PART 4: INTERFACES
%==============================================================================
\newpage
\section{Interfaces}

\subsection{What is an Interface?}

\begin{definitionbox}[Definition]
An \textbf{Interface} is a completely abstract type that defines a contract of methods that implementing classes must follow. It specifies WHAT a class must do, but not HOW it does it.
\end{definitionbox}

\subsection{Interface Syntax}

\begin{lstlisting}
interface InterfaceName {
    // Constants (implicitly public static final)
    int MAX_VALUE = 100;

    // Abstract methods (implicitly public abstract)
    void method1();
    int method2(String param);

    // Default method (Java 8+)
    default void defaultMethod() {
        System.out.println("Default implementation");
    }

    // Static method (Java 8+)
    static void staticMethod() {
        System.out.println("Static method in interface");
    }
}
\end{lstlisting}

\subsection{Implementing an Interface}

\begin{lstlisting}
interface Drawable {
    void draw();
    void resize(int percentage);
}

class Circle implements Drawable {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public void draw() {
        System.out.println("Drawing a circle with radius " + radius);
    }

    @Override
    public void resize(int percentage) {
        radius = radius * percentage / 100;
        System.out.println("Circle resized. New radius: " + radius);
    }
}
\end{lstlisting}

\subsection{Multiple Interface Implementation}

A class can implement multiple interfaces (Java's way of achieving multiple inheritance):

\begin{lstlisting}
interface Playable {
    void play();
    void stop();
}

interface Recordable {
    void record();
    void stopRecording();
}

interface Streamable {
    void stream(String url);
}

// A class implementing multiple interfaces
class MediaPlayer implements Playable, Recordable, Streamable {
    private String currentMedia;
    private boolean isPlaying = false;
    private boolean isRecording = false;

    @Override
    public void play() {
        isPlaying = true;
        System.out.println("Playing media...");
    }

    @Override
    public void stop() {
        isPlaying = false;
        System.out.println("Stopped playing.");
    }

    @Override
    public void record() {
        isRecording = true;
        System.out.println("Recording started...");
    }

    @Override
    public void stopRecording() {
        isRecording = false;
        System.out.println("Recording stopped.");
    }

    @Override
    public void stream(String url) {
        System.out.println("Streaming from: " + url);
    }
}
\end{lstlisting}

\subsection{Interface vs Abstract Class}

\begin{center}
\begin{tabular}{|p{6cm}|p{6cm}|}
\hline
\textbf{Abstract Class} & \textbf{Interface} \\
\hline
Can have abstract and concrete methods & All methods are abstract (except default/static) \\
\hline
Can have instance variables & Can only have constants (static final) \\
\hline
Can have constructors & Cannot have constructors \\
\hline
Single inheritance only & Multiple implementation allowed \\
\hline
Use \texttt{extends} keyword & Use \texttt{implements} keyword \\
\hline
Can have any access modifier & Methods are implicitly public \\
\hline
Represents "is-a" relationship & Represents "can-do" capability \\
\hline
\end{tabular}
\end{center}

\subsection{Real-World Example: E-commerce System}

\begin{lstlisting}
// Interfaces defining capabilities
interface Sellable {
    double getPrice();
    void applyDiscount(double percentage);
}

interface Shippable {
    double getWeight();
    String getShippingDimensions();
    double calculateShippingCost(String destination);
}

interface Reviewable {
    void addReview(String review, int rating);
    double getAverageRating();
}

// Product class implementing multiple interfaces
class Product implements Sellable, Shippable, Reviewable {
    private String name;
    private double price;
    private double weight;
    private String dimensions;
    private java.util.List<Integer> ratings = new java.util.ArrayList<>();

    public Product(String name, double price, double weight, String dims) {
        this.name = name;
        this.price = price;
        this.weight = weight;
        this.dimensions = dims;
    }

    // Sellable implementation
    @Override
    public double getPrice() {
        return price;
    }

    @Override
    public void applyDiscount(double percentage) {
        price = price * (1 - percentage / 100);
        System.out.println(name + " new price: $" + price);
    }

    // Shippable implementation
    @Override
    public double getWeight() {
        return weight;
    }

    @Override
    public String getShippingDimensions() {
        return dimensions;
    }

    @Override
    public double calculateShippingCost(String destination) {
        double baseCost = weight * 0.5;
        if (destination.equals("international")) {
            baseCost *= 3;
        }
        return baseCost;
    }

    // Reviewable implementation
    @Override
    public void addReview(String review, int rating) {
        ratings.add(rating);
        System.out.println("Review added: " + review + " (" + rating + "/5)");
    }

    @Override
    public double getAverageRating() {
        if (ratings.isEmpty()) return 0;
        int sum = 0;
        for (int r : ratings) sum += r;
        return (double) sum / ratings.size();
    }

    public void displayInfo() {
        System.out.println("Product: " + name);
        System.out.println("Price: $" + price);
        System.out.println("Weight: " + weight + " kg");
        System.out.println("Rating: " + getAverageRating() + "/5");
    }
}

public class InterfaceDemo {
    public static void main(String[] args) {
        Product laptop = new Product("Laptop Pro", 1200.00, 2.5, "35x25x2 cm");

        laptop.displayInfo();
        System.out.println();

        laptop.addReview("Great performance!", 5);
        laptop.addReview("Good value", 4);
        laptop.addReview("Battery could be better", 3);

        System.out.println("\nAverage Rating: " + laptop.getAverageRating());

        laptop.applyDiscount(10);

        System.out.println("\nShipping cost (local): $" +
                           laptop.calculateShippingCost("local"));
        System.out.println("Shipping cost (international): $" +
                           laptop.calculateShippingCost("international"));
    }
}
\end{lstlisting}

%==============================================================================
% PART 5: COMBINING CONCEPTS
%==============================================================================
\newpage
\section{Combining All Concepts}

\subsection{Comprehensive Example: Animal Shelter System}

\begin{lstlisting}
// Interface for adoptable animals
interface Adoptable {
    boolean isAvailableForAdoption();
    void adopt(String ownerName);
    double getAdoptionFee();
}

// Interface for animals that can be trained
interface Trainable {
    void train(String command);
    String[] getLearnedCommands();
}

// Abstract base class
abstract class Animal {
    protected String name;
    protected int age;
    protected String species;

    public Animal(String name, int age, String species) {
        this.name = name;
        this.age = age;
        this.species = species;
    }

    public abstract void makeSound();
    public abstract void eat();

    public void sleep() {
        System.out.println(name + " is sleeping. Zzz...");
    }

    public void displayInfo() {
        System.out.println("Name: " + name);
        System.out.println("Age: " + age + " years");
        System.out.println("Species: " + species);
    }
}

// Dog class - extends Animal, implements interfaces
class Dog extends Animal implements Adoptable, Trainable {
    private String breed;
    private boolean adopted = false;
    private String ownerName;
    private java.util.List<String> commands = new java.util.ArrayList<>();

    public Dog(String name, int age, String breed) {
        super(name, age, "Dog");
        this.breed = breed;
    }

    @Override
    public void makeSound() {
        System.out.println(name + " barks: Woof! Woof!");
    }

    @Override
    public void eat() {
        System.out.println(name + " is eating dog food.");
    }

    // Adoptable implementation
    @Override
    public boolean isAvailableForAdoption() {
        return !adopted;
    }

    @Override
    public void adopt(String ownerName) {
        this.adopted = true;
        this.ownerName = ownerName;
        System.out.println(name + " has been adopted by " + ownerName + "!");
    }

    @Override
    public double getAdoptionFee() {
        return 150.00;
    }

    // Trainable implementation
    @Override
    public void train(String command) {
        commands.add(command);
        System.out.println(name + " learned: " + command);
    }

    @Override
    public String[] getLearnedCommands() {
        return commands.toArray(new String[0]);
    }

    @Override
    public void displayInfo() {
        super.displayInfo();
        System.out.println("Breed: " + breed);
        System.out.println("Adopted: " + (adopted ? "Yes by " + ownerName : "No"));
    }
}

// Cat class - extends Animal, implements Adoptable only
class Cat extends Animal implements Adoptable {
    private boolean isIndoor;
    private boolean adopted = false;

    public Cat(String name, int age, boolean isIndoor) {
        super(name, age, "Cat");
        this.isIndoor = isIndoor;
    }

    @Override
    public void makeSound() {
        System.out.println(name + " meows: Meow!");
    }

    @Override
    public void eat() {
        System.out.println(name + " is eating cat food.");
    }

    @Override
    public boolean isAvailableForAdoption() {
        return !adopted;
    }

    @Override
    public void adopt(String ownerName) {
        this.adopted = true;
        System.out.println(name + " has been adopted by " + ownerName + "!");
    }

    @Override
    public double getAdoptionFee() {
        return 100.00;
    }
}

// Main demonstration
public class AnimalShelterDemo {
    public static void main(String[] args) {
        // Create animals
        Dog buddy = new Dog("Buddy", 3, "Golden Retriever");
        Dog max = new Dog("Max", 2, "German Shepherd");
        Cat whiskers = new Cat("Whiskers", 4, true);

        System.out.println("=== Animal Shelter System ===\n");

        // Polymorphism with Animal reference
        Animal[] animals = {buddy, max, whiskers};

        System.out.println("--- All Animals ---");
        for (Animal a : animals) {
            a.displayInfo();
            a.makeSound();
            System.out.println();
        }

        // Polymorphism with interface reference
        System.out.println("--- Adoptable Animals ---");
        Adoptable[] adoptables = {buddy, max, whiskers};

        for (Adoptable a : adoptables) {
            if (a.isAvailableForAdoption()) {
                System.out.println("Adoption fee: $" + a.getAdoptionFee());
            }
        }

        System.out.println("\n--- Training Session ---");
        buddy.train("Sit");
        buddy.train("Stay");
        buddy.train("Fetch");

        System.out.println("\n" + buddy.name + "'s commands:");
        for (String cmd : buddy.getLearnedCommands()) {
            System.out.println("  - " + cmd);
        }

        System.out.println("\n--- Adoption Process ---");
        buddy.adopt("John Smith");
        whiskers.adopt("Jane Doe");

        System.out.println("\n--- Updated Status ---");
        buddy.displayInfo();
    }
}
\end{lstlisting}

%==============================================================================
% PART 6: EXERCISES
%==============================================================================
\newpage
\section{Exercises}

\begin{exercisebox}[Exercise 1: Basic Inheritance]
Create a class hierarchy for a university system:
\begin{enumerate}
    \item Create a base class \texttt{Person} with attributes: \texttt{name}, \texttt{age}, \texttt{email}
    \item Create a derived class \texttt{Student} that adds: \texttt{studentId}, \texttt{major}, \texttt{gpa}
    \item Create a derived class \texttt{Professor} that adds: \texttt{employeeId}, \texttt{department}, \texttt{salary}
    \item Implement appropriate constructors using \texttt{super}
    \item Override \texttt{toString()} method in each class
    \item Create a main method to test your classes
\end{enumerate}
\end{exercisebox}

\begin{exercisebox}[Exercise 2: Method Overloading]
Create a \texttt{MathOperations} class with overloaded methods:
\begin{enumerate}
    \item \texttt{multiply(int, int)} - returns product of two integers
    \item \texttt{multiply(int, int, int)} - returns product of three integers
    \item \texttt{multiply(double, double)} - returns product of two doubles
    \item \texttt{multiply(int[], int)} - multiplies each array element by the integer
    \item Test all methods in main
\end{enumerate}
\end{exercisebox}

\begin{exercisebox}[Exercise 3: Method Overriding and Polymorphism]
Create a vehicle rental system:
\begin{enumerate}
    \item Base class \texttt{Vehicle} with: \texttt{brand}, \texttt{model}, \texttt{dailyRate}
    \item Method \texttt{calculateRentalCost(int days)}
    \item Derived classes: \texttt{Car}, \texttt{Motorcycle}, \texttt{Truck}
    \item Override \texttt{calculateRentalCost()} with different rates:
    \begin{itemize}
        \item Car: base rate
        \item Motorcycle: 20\% discount
        \item Truck: 50\% surcharge
    \end{itemize}
    \item Use polymorphism to process an array of vehicles
\end{enumerate}
\end{exercisebox}

\begin{exercisebox}[Exercise 4: Abstract Class]
Create an abstract class for a banking system:
\begin{enumerate}
    \item Abstract class \texttt{BankAccount} with:
    \begin{itemize}
        \item Attributes: \texttt{accountNumber}, \texttt{balance}, \texttt{ownerName}
        \item Abstract methods: \texttt{withdraw()}, \texttt{calculateInterest()}
        \item Concrete methods: \texttt{deposit()}, \texttt{getBalance()}
    \end{itemize}
    \item Concrete class \texttt{SavingsAccount}:
    \begin{itemize}
        \item Interest rate: 4\% annually
        \item Minimum balance: \$100
    \end{itemize}
    \item Concrete class \texttt{CheckingAccount}:
    \begin{itemize}
        \item No interest
        \item Overdraft limit: \$500
    \end{itemize}
\end{enumerate}
\end{exercisebox}

\begin{exercisebox}[Exercise 5: Interfaces]
Design a smart home system using interfaces:
\begin{enumerate}
    \item Interface \texttt{Switchable}: \texttt{turnOn()}, \texttt{turnOff()}, \texttt{isOn()}
    \item Interface \texttt{Adjustable}: \texttt{increaseLevel()}, \texttt{decreaseLevel()}, \texttt{getLevel()}
    \item Interface \texttt{Programmable}: \texttt{setTimer(int minutes)}, \texttt{cancelTimer()}
    \item Create classes implementing these interfaces:
    \begin{itemize}
        \item \texttt{SmartLight} - implements all three
        \item \texttt{SmartFan} - implements Switchable and Adjustable
        \item \texttt{SmartTV} - implements Switchable and Programmable
    \end{itemize}
    \item Demonstrate polymorphism using interface references
\end{enumerate}
\end{exercisebox}

\begin{exercisebox}[Exercise 6: Comprehensive Challenge]
Create a complete Library Management System:
\begin{enumerate}
    \item Abstract class \texttt{LibraryItem} with: \texttt{title}, \texttt{itemId}, \texttt{isAvailable}
    \item Interface \texttt{Borrowable}: \texttt{borrow()}, \texttt{returnItem()}, \texttt{getDueDate()}
    \item Interface \texttt{Reservable}: \texttt{reserve()}, \texttt{cancelReservation()}
    \item Classes: \texttt{Book}, \texttt{DVD}, \texttt{Magazine}
    \begin{itemize}
        \item Book: implements Borrowable and Reservable
        \item DVD: implements Borrowable only
        \item Magazine: implements neither (reference only)
    \end{itemize}
    \item Each class should override appropriate methods
    \item Create a \texttt{Library} class that manages all items
    \item Demonstrate all concepts learned in this lecture
\end{enumerate}
\end{exercisebox}

%==============================================================================
% SUMMARY
%==============================================================================
\newpage
\section{Summary}

\subsection{Key Takeaways}

\begin{itemize}
    \item \textbf{Inheritance} allows code reuse through parent-child relationships using \texttt{extends}
    \item \textbf{Polymorphism} enables objects to take multiple forms through overloading and overriding
    \item \textbf{Abstract Classes} provide partial implementation and define contracts for subclasses
    \item \textbf{Interfaces} define pure contracts and enable multiple inheritance of behavior
\end{itemize}

\subsection{When to Use What}

\begin{center}
\begin{tabular}{|p{4cm}|p{9cm}|}
\hline
\textbf{Concept} & \textbf{Use When} \\
\hline
Inheritance & Classes share common attributes and have "is-a" relationship \\
\hline
Method Overloading & Same operation needs to work with different parameters \\
\hline
Method Overriding & Subclass needs to provide specific implementation \\
\hline
Abstract Class & Want to share code among related classes with some abstract behavior \\
\hline
Interface & Want to define a contract that unrelated classes can implement \\
\hline
\end{tabular}
\end{center}

\subsection{Best Practices}

\begin{enumerate}
    \item Always use \texttt{@Override} annotation when overriding methods
    \item Prefer composition over inheritance when appropriate
    \item Program to interfaces, not implementations
    \item Keep inheritance hierarchies shallow (2-3 levels max)
    \item Use abstract classes for related classes; interfaces for unrelated classes
    \item Follow the Liskov Substitution Principle: subclasses should be substitutable for their base classes
\end{enumerate}

\vspace{1cm}
\begin{center}
\textit{Practice these concepts by completing the exercises. Understanding inheritance, polymorphism, abstract classes, and interfaces is fundamental to mastering object-oriented programming.}
\end{center}

\end{document}
